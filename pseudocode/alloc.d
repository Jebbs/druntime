module alloc;

//defined in gc.os module. These are designed to allocate pages at a time.
void *os_mem_map(size_t nbytes) nothrow;
int os_mem_unmap(void *base, size_t nbytes) nothrow;

enum PAGE_SIZE = 4096;//4kb

/**
 * MemoryChunk describes a chunk of memory obtained directly from the OS.
 */
struct MemoryChunk
{
    /// The start of the memory this chunk describes.
    void* start;
    /// The size of the MemoryChunk.
    size_t chunkSize;
    /// Where in the chunk to pop memory from when allocating.
    void* offset;
    /// A reference to the next chunk.
    //(used to avoid an additional structure for making a linked list)
    MemoryChunk* nextChunk;

    //MemoryChunk constructor.
    //Initializes this chunk with new memory from the OS
    this(size_t size)
    {
        chunkSize = size;
        start = os_mem_map(chunkSize);
        if(start is null)
        {
            //throw an out of memory error
        }
        offset = start;
        nextChunk = null;
    }
}

//initialized to 64kb/1Mb (256 pages) and assumed to not grow
//(too much memory to start?)
MemoryChunk systemMemory;

//the list of all memory chunks used by the heap. initialized with a chunk
MemoryChunk* heapMemory;
//the chunk currently used to perform allocations
MemoryChunk* currentChunk;

//describes the boundaries of the GC managed heap
//these are used when searching for pointers
//(if not in these bounds, we won't perform a search)
void* memBottom, memTop;

void systemInit()
{
    systemMemory = MemoryChunk(256*PAGE_SIZE);

    heapMemory = cast(MemoryChunk*)salloc(MemoryChunk.sizeof);

    *heapMemory = MemoryChunk(2*PAGE_SIZE); //is this enough to start?

    currentChunk = heapMemory;

    memBottom = currentChunk.start;
    memTop = currentChunk.start + currentChunk.size;

}

/**
 * System Alloc.
 *
 * This is used to allocate for internal structures. It is assumed to never fail
 * for 2 reasons:
 *  1. There is plenty of memory for the system to use internally. We should
 *     always have enough.
 *  2. The memory usage for a program should eventually hit a peak. Given enough
 *     time, there will be plenty of storage space after a collection to not
 *     warrant creating more internal objects.
 */
void* salloc(size_t size)
{
    void* oldOffset = systemMemory.offset;
    systemMemory.offset += size;
    return oldOffset;
}

/**
 * Heap Alloc.
 *
 * This is used to get GC managed memory for new buckets to use. This allocator
 * is lazy in the sense that if it doesn't have enough room in one memory chunk
 * to fulfill an allocation, it makes a new one.
 *
 * This can/should be optimized later to avoid fragmentation.
 *
 * This allocation could possibly fail, and will throw an OutOfMemoryError if it
 * does.
 */
void* halloc(size_t)
{

    if(currentChunk.offset+size <= start+currentChunk.chunkSize)
    {
        MemoryChunk* newChunk = cast(MemoryChunk*)salloc(MemoryChunk.sizeof);
        size_t newChunkSize = 2*PAGE_SIZE;//or something generated by a growth algorithm?

        (*newChunk) = MemoryChunk(newChunkSize); //may throw out of memory error

        currentChunk.nextChunk = newChunk;
        currentChunk = newChunk;

        //adjust the heap boundaries
        if(currentChunk.start < memBottom)
            memBottom = currentChunk.start;

        if(memTop < currentChunk.start + currentChunk.size)
            memTop = currentChunk.start + currentChunk.size;


    }

    void* oldOffset = currentChunk.offset;
    currentChunk.offset += size;
    return oldOffset;
}
